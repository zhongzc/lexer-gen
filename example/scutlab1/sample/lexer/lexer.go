// generated by goGen.go - do not edit
package lexer

import (
	"errors"
	"fmt"
	"regexp/syntax"
	"unicode"
)

// Lexer
type Lexer struct {
	Chars     CharIterator
	automatas []struct{
		Name string
		Automata Automata
	}
}

func NewLexer(chars CharIterator) *Lexer {
	return &Lexer{
		Chars: chars,
		automatas: []struct{
			Name string
			Automata Automata
		}{
			{"t01", &t01{}},
			{"t02", &t02{}},
			{"t03", &t03{}},
			{"t04", &t04{}},
			{"t05", &t05{}},
			{"t06", &t06{}},
			{"t07", &t07{}},
			{"t08", &t08{}},
			{"t09", &t09{}},
			{"t10", &t10{}},
			{"t11", &t11{}},
			{"t12", &t12{}},
			{"t13", &t13{}},
			{"t14", &t14{}},
			{"t15", &t15{}},
			{"t16", &t16{}},
			{"t17", &t17{}},
			{"t18", &t18{}},
			{"t19", &t19{}},
			{"t20", &t20{}},
			{"t21", &t21{}},
			{"t22", &t22{}},
			{"t23", &t23{}},
			{"t24", &t24{}},
			{"t25", &t25{}},
			{"t26", &t26{}},
			{"t27", &t27{}},
			{"t28", &t28{}},
			{"t29", &t29{}},
			{"t30", &t30{}},
			{"t31", &t31{}},
			{"t32", &t32{}},
			{"t33", &t33{}},
			{"t34", &t34{}},
			{"t35", &t35{}},
			{"t36", &t36{}},
			{"t37", &t37{}},
			{"t38", &t38{}},
			{"t39", &t39{}},
			{"t40", &t40{}},
			{"t42", &t42{}},
			{"t41", &t41{}},
			{"t43", &t43{}},
			{"t44", &t44{}},
			{"t45", &t45{}},
			{"t47", &t47{}},
			{"t46", &t46{}},
			{"t48", &t48{}},
			{"t51", &t51{}},
			{"t50", &t50{}},
			{"t52", &t52{}},
			{"t54", &t54{}},
			{"t55", &t55{}},
			{"t53", &t53{}},
			{"t56", &t56{}},
			{"t58", &t58{}},
			{"t57", &t57{}},
			{"t59", &t59{}},
			{"t60", &t60{}},
		},
	}
}

func (l *Lexer) NextToken() (t *Token, err error) {
	if l.Chars.Peek() == 0 {
		return nil, errors.New("reach EOF")
	}
	l.skipWhitespace()
	idx := l.Chars.CurrentIndex()

	for _, a := range l.automatas {
		err = a.Automata.RunGreedy(l.Chars)
		if err != nil {
			if a.Name == "t42" && l.Chars.CurrentIndex()-idx > 1 {
				loc := l.Chars.Loc(idx)
				msg := fmt.Sprintf("\nincomplete comment. at line %d, col %d\n", loc.Line, loc.Col)
				return nil, errors.New(msg)
			} else if a.Name == "t38" && idx != l.Chars.CurrentIndex() {
				loc := l.Chars.Loc(idx)
				msg := fmt.Sprintf("\nincomplete characters. at line %d, col %d\n", loc.Line, loc.Col)
				return nil, errors.New(msg)
			}
			l.Chars.SetIndex(idx)
		} else {
			if a.Name == "t37" && syntax.IsWordChar(l.Chars.Peek()) {
				loc := l.Chars.Loc(l.Chars.CurrentIndex())
				msg := fmt.Sprintf("\nwrong delimiter: %c. at line %d, col %d\n", l.Chars.Peek(),
					loc.Line, loc.Col)
				return nil, errors.New(msg)
			}

			var tv = l.Chars.SubString(idx, l.Chars.CurrentIndex())
			idx = l.Chars.CurrentIndex()
			t = &Token{TokenType(a.Name), TokenValue(tv)}
			err = nil

			l.skipWhitespace()
			return
		}
	}

	loc := l.Chars.Loc(idx)
	msg := fmt.Sprintf("\nunexpected char: %c. at line %d, col %d\n", l.Chars.Peek(), loc.Line, loc.Col)
	return nil, errors.New(msg)
}


func (l *Lexer) HasNext() bool {
	return l.Chars.Peek() != 0
}

func (l *Lexer) skipWhitespace() {
	c := l.Chars.Peek()
	for unicode.IsSpace(c) {
		l.Chars.NextChar()
		c = l.Chars.Peek()
	}
}

// Token
type TokenType string
type TokenValue string
type Token struct {
	Type  TokenType
	Token TokenValue
}
