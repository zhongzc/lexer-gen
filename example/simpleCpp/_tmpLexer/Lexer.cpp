// generated by cppGen.go - do not edit
#include "Lexer.h"

#include <utility>
#include <memory>

Lexer::Lexer(CharReader &charReader) : charReader(charReader) {
    this->automatas.push_back(std::unique_ptr<Automata>(new IF));
    this->automatas.push_back(std::unique_ptr<Automata>(new ELSE));
    this->automatas.push_back(std::unique_ptr<Automata>(new LPAREN));
    this->automatas.push_back(std::unique_ptr<Automata>(new RPAREN));
    this->automatas.push_back(std::unique_ptr<Automata>(new LBRACKET));
    this->automatas.push_back(std::unique_ptr<Automata>(new RBRACKET));
    this->automatas.push_back(std::unique_ptr<Automata>(new SEMICOLON));
    this->automatas.push_back(std::unique_ptr<Automata>(new VAR));
    this->automatas.push_back(std::unique_ptr<Automata>(new RETURN));
    this->automatas.push_back(std::unique_ptr<Automata>(new EQ));
    this->automatas.push_back(std::unique_ptr<Automata>(new ASSIGN));
    this->automatas.push_back(std::unique_ptr<Automata>(new NUM));
    this->automatas.push_back(std::unique_ptr<Automata>(new IDENT));
    this->automatas.push_back(std::unique_ptr<Automata>(new MCOMMENT));
    this->automatas.push_back(std::unique_ptr<Automata>(new SCOMMENT));

}

Token Lexer::nextToken() {
    if (!this->hasNext()) {
        throw std::runtime_error("reach EOF");
    }
    this->skipWhitespace();

    for (const auto &a : this->automatas) {
        auto o = this->charReader.curIdx();
        a->runGreedy(this->charReader);
        auto n = this->charReader.curIdx();

        if (o == n) {
            continue;
        } else {
            auto res = Token(a->name(), CharReader::subString(o, n));
            this->skipWhitespace();
            return res;
        }
    }

    throw std::runtime_error("unexpected token");
}

bool Lexer::hasNext() {
    return this->charReader.peek() != 0;
}

void Lexer::skipWhitespace() {
    auto p = this->charReader.peek();
    while (std::iswspace(p)) {
        this->charReader.nextChar();
        p = this->charReader.peek();
    }
}


Token::Token(TokenType type, TokenValue token) : type(std::move(type)), token(std::move(token)) {}

std::ostream &operator<<(std::ostream &os, const Token &token) {
    os << "type: " << token.type << " token: " << token.token;
    return os;
}