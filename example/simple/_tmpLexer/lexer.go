// generated by goGen.go - do not edit
package lexer

import (
	"errors"
	"fmt"
	"unicode"
)

// Lexer
type Lexer struct {
	Chars     CharIterator
	automatas []struct {
		Name     string
		Automata Automata
	}
}

func NewLexer(chars CharIterator) *Lexer {
	return &Lexer{
		Chars: chars,
		automatas: []struct {
			Name     string
			Automata Automata
		}{
			{"IF", &IF{}},
			{"ELSE", &ELSE{}},
			{"LPAREN", &LPAREN{}},
			{"RPAREN", &RPAREN{}},
			{"LBRACKET", &LBRACKET{}},
			{"RBRACKET", &RBRACKET{}},
			{"SEMICOLON", &SEMICOLON{}},
			{"VAR", &VAR{}},
			{"RETURN", &RETURN{}},
			{"EQ", &EQ{}},
			{"ASSIGN", &ASSIGN{}},
			{"NUM", &NUM{}},
			{"IDENT", &IDENT{}},
			{"MCOMMENT", &MCOMMENT{}},
			{"SCOMMENT", &SCOMMENT{}},
		},
	}
}

func (l *Lexer) NextToken() (t *Token, err error) {
	if l.Chars.Peek() == 0 {
		return nil, errors.New("reach EOF")
	}
	l.skipWhitespace()
	idx := l.Chars.CurrentIndex()

	for _, a := range l.automatas {
		err = a.Automata.RunGreedy(l.Chars)
		if err != nil {
			l.Chars.SetIndex(idx)
		} else {
			var tv = l.Chars.SubString(idx, l.Chars.CurrentIndex())
			idx = l.Chars.CurrentIndex()

			t = &Token{TokenType(a.Name), TokenValue(tv)}
			err = nil
			l.skipWhitespace()
			return
		}
	}

	loc := l.Chars.Loc(idx)
	msg := fmt.Sprintf("unexpected char: %c. at line %d, col %d", l.Chars.Peek(), loc.Line, loc.Col)
	return nil, errors.New(msg)
}

func (l *Lexer) HasNext() bool {
	return l.Chars.Peek() != 0
}

func (l *Lexer) skipWhitespace() {
	c := l.Chars.Peek()
	for unicode.IsSpace(c) {
		l.Chars.NextChar()
		c = l.Chars.Peek()
	}
}

// Token
type TokenType string
type TokenValue string
type Token struct {
	Type  TokenType
	Token TokenValue
}
