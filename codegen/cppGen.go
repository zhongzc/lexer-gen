package codegen

import (
	"bytes"
	"fmt"
	"io"
	"unicode"
)

type CppGen struct{}

func NewCppGen() *CppGen {
	return &CppGen{}
}

func (cg *CppGen) Generate(dfas []*NamedDFA) map[string]func(io.Writer) error {
	res := make(map[string]func(io.Writer) error)
	res["CMakeLists.txt"] = genCMake()
	res["Lexer.h"] = genLexerH()
	res["Lexer.cpp"] = genLexerCpp(dfas)
	res["UnicodeDef.h"] = genUDef()
	res["CharReader.h"] = genCharReaderH()
	res["CharReader.cpp"] = genCharReaderCpp()
	res["Automata.h"] = genAutomataH(dfas)
	res["Automata.cpp"] = genAutomataCpp(dfas)
	res["main.cpp"] = genMain()
	return res
}

// gen main.cpp
func genMain() func(io.Writer) error {
	return func(writer io.Writer) (err error) {
		_, err = io.WriteString(writer, main)
		if err != nil {
			return
		}
		return
	}
}

const (
	main = `#include <iostream>
#include <memory>
#include "CharReader.h"
#include "Lexer.h"

int main() {
    std::string s("if (a_for_apple == 10000) {\n"
                  "\tvar b_for_ball = 10086;\n"
                  "\treturn b_for_banana;\n"
                  "\t// a single-line comment\n"
                  "} else {\n"
                  "\t/*\n"
                  "\ta multi-line comment\n"
                  "\tcooooooool!\n"
                  "\t*/\n"
                  "\treturn 0;\n"
                  "}");
    auto cr = CharReader(s);
    auto lx = Lexer(cr);
    while (lx.hasNext()) {
        std::cout << lx.nextToken() << std::endl;
    }
}`
)

func genAutomataCpp(dfas []*NamedDFA) func(io.Writer) error {
	return func(writer io.Writer) (err error) {
		_, err = io.WriteString(writer, amCppHeader)
		if err != nil {
			return
		}

		for _, lx := range dfas {
			c := buildTranCode(lx)
			_, err = io.WriteString(writer, c)
			if err != nil {
				return
			}
		}

		return
	}
}

func buildTranCode(dfa *NamedDFA) string {
	var buf bytes.Buffer

	start := dfa.StartState
	startR := dfa.Rules[dfa.StartState]
	var transferRules bytes.Buffer
	for _, rule := range startR {
		var str string
		if rule.By.LeftMost == rule.By.RightMost {
			str = fmt.Sprintf(tranTemp, wrapCppChar(rule.By.LeftMost), rule.To)
		} else {
			str = fmt.Sprintf(tran2Temp, wrapCppChar(rule.By.LeftMost), wrapCppChar(rule.By.RightMost), rule.To)
		}
		transferRules.WriteString(str)
	}
	var next string
	if dfa.AcceptStates[start] {
		next = "accept"
	} else {
		next = "bad"
	}
	buf.WriteString(fmt.Sprintf(ruleTemp, start, transferRules.String(), next))

	for from, transfer := range dfa.Rules {
		if from == start {
			continue
		}

		var transferRules bytes.Buffer
		for _, rule := range transfer {
			var str string
			if rule.By.LeftMost == rule.By.RightMost {
				str = fmt.Sprintf(tranTemp, wrapCppChar(rule.By.LeftMost), rule.To)
			} else {
				str = fmt.Sprintf(tran2Temp, wrapCppChar(rule.By.LeftMost), wrapCppChar(rule.By.RightMost), rule.To)
			}
			transferRules.WriteString(str)
		}
		var next string
		if dfa.AcceptStates[from] {
			next = "accept"
		} else {
			next = "bad"
		}
		delete(dfa.AcceptStates, from)
		buf.WriteString(fmt.Sprintf(ruleTemp, from, transferRules.String(), next))
	}

	var other bytes.Buffer
	for a := range dfa.AcceptStates {
		other.WriteString(fmt.Sprintf("s%d:\n", a))
	}

	return fmt.Sprintf(runGTemp, dfa.Name, buf.String(), other.String(), dfa.Name, dfa.Name)
}

const (
	amCppHeader = `// generated by cppGen.go - do not edit
#include "Automata.h"
`
	runGTemp = `
void %s::runGreedy(CharReader& reader) {
    auto old = reader.curIdx();
    char32_t c;
%s

bad:
    reader.setCurIdx(old);
    return;

%s	reader.nextChar();
accept:
	reader.setCurIdx(reader.curIdx() - 1);
    return;
}

std::string %s::name() {
    return "%s";
}
`

	ruleTemp = `
s%d:
    c = reader.nextChar();%s
    goto %s;`

	tran2Temp = `
    if (%s <= c && c <= %s) {
        goto s%d;
    }`
	tranTemp = `
    if (c == %s) {
        goto s%d;
    }`
)

// gen Automata.h
func genAutomataH(dfas []*NamedDFA) func(io.Writer) error {
	return func(writer io.Writer) (err error) {
		var nameBuf bytes.Buffer
		for _, lx := range dfas {
			nameBuf.WriteString(fmt.Sprintf(automatatTemplate, lx.Name))
		}
		_, err = io.WriteString(writer, fmt.Sprintf(amH, nameBuf.String()))
		return
	}
}

const (
	amH = `// generated by cppGen.go - do not edit
#ifndef CPPLEXERTEMPLATE_AUTOMATA_H
#define CPPLEXERTEMPLATE_AUTOMATA_H


#include <memory>
#include "CharReader.h"

class Automata {
public:
    virtual void runGreedy(CharReader& reader) = 0;

    virtual std::string name() = 0;

    virtual ~Automata() = default;
};

%s

#endif //CPPLEXERTEMPLATE_AUTOMATA_H`

	automatatTemplate = `
class %s : public Automata {
    void runGreedy(CharReader& reader) override;

    std::string name() override;
};`
)

// gen CharReader.cpp
func genCharReaderCpp() func(io.Writer) error {
	return func(writer io.Writer) (err error) {
		_, err = io.WriteString(writer, crCpp)
		if err != nil {
			return
		}
		return
	}
}

const (
	crCpp = `// generated by cppGen.go - do not edit
#include "CharReader.h"

CharReader::CharReader(
        const std::u32string::iterator &begin,
        const std::u32string::iterator &end) : cur(begin), end(end) {}

CharReader::CharReader(const std::string& s) {
    this->str = cvt32.from_bytes(s);
    this->cur = this->str.begin();
    this->end = this->str.end();
}

char32_t CharReader::peek() {
    if (this->cur > this->end) {
        return 0;
    }
    return *this->cur;
}

char32_t CharReader::nextChar() {
    if (this->cur > this->end) {
        return 0;
    }
    auto c = *this->cur;
    this->cur += 1;
    return c;
}

void CharReader::setCurIdx(const std::u32string::iterator &c) {
    this->cur = c;
}

std::string CharReader::subString(const std::u32string::iterator &b, const std::u32string::iterator &e) {
    return cvt32.to_bytes(&(*(b)), &(*(e)));
}

const std::u32string::iterator &CharReader::curIdx() {
    return this->cur;
}
`
)

// gen CharReader.h
func genCharReaderH() func(io.Writer) error {
	return func(writer io.Writer) (err error) {
		_, err = io.WriteString(writer, crH)
		if err != nil {
			return
		}
		return
	}
}

const (
	crH = `// generated by cppGen.go - do not edit
#ifndef CPPLEXERTEMPLATE_CHARREADER_H
#define CPPLEXERTEMPLATE_CHARREADER_H

#include "UnicodeDef.h"

class CharReader {
public:
    CharReader(const std::u32string::iterator &begin,
               const std::u32string::iterator &end);
    explicit CharReader(const std::string &s);

    char32_t peek();

    char32_t nextChar();

    void setCurIdx(const std::u32string::iterator &c);

    static std::string subString(const std::u32string::iterator &b, const std::u32string::iterator &e);

    const std::u32string::iterator &curIdx();

private:
    std::u32string str;
    std::u32string::iterator cur;
    std::u32string::iterator end;
};


#endif //CPPLEXERTEMPLATE_CHARREADER_H`
)

// gen UnicodeDef.h
func genUDef() func(io.Writer) error {
	return func(writer io.Writer) (err error) {
		_, err = io.WriteString(writer, udef)
		if err != nil {
			return
		}
		return
	}
}

const (
	udef = `// generated by cppGen.go - do not edit
#ifndef CPPLEXERTEMPLATE_UNICODEDEF_H
#define CPPLEXERTEMPLATE_UNICODEDEF_H

#include <locale>
#include <codecvt>

static std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> cvt32;

#endif //CPPLEXERTEMPLATE_UNICODEDEF_H`
)

// gen lexer.cpp
func genLexerCpp(dfas []*NamedDFA) func(io.Writer) error {
	return func(writer io.Writer) (err error) {
		var nameBuf bytes.Buffer
		for _, lx := range dfas {
			nameBuf.WriteString(fmt.Sprintf(aTemplate, lx.Name))
		}
		_, err = io.WriteString(writer, fmt.Sprintf(lexerCpp, nameBuf.String()))
		return
	}
}

const (
	aTemplate = `    this->automatas.push_back(std::unique_ptr<Automata>(new %s));
`
	lexerCpp = `// generated by cppGen.go - do not edit
#include "Lexer.h"

#include <utility>
#include <memory>

Lexer::Lexer(CharReader &charReader) : charReader(charReader) {
%s
}

Token Lexer::nextToken() {
    if (!this->hasNext()) {
        throw std::runtime_error("reach EOF");
    }
    this->skipWhitespace();

    for (const auto &a : this->automatas) {
        auto o = this->charReader.curIdx();
        a->runGreedy(this->charReader);
        auto n = this->charReader.curIdx();

        if (o == n) {
            continue;
        } else {
            auto res = Token(a->name(), CharReader::subString(o, n));
            this->skipWhitespace();
            return res;
        }
    }

    throw std::runtime_error("unexpected token");
}

bool Lexer::hasNext() {
    return this->charReader.peek() != 0;
}

void Lexer::skipWhitespace() {
    auto p = this->charReader.peek();
    while (std::iswspace(p)) {
        this->charReader.nextChar();
        p = this->charReader.peek();
    }
}


Token::Token(TokenType type, TokenValue token) : type(std::move(type)), token(std::move(token)) {}

std::ostream &operator<<(std::ostream &os, const Token &token) {
    os << "type: " << token.type << " token: " << token.token;
    return os;
}`
)

// gen lexer.h
func genLexerH() func(io.Writer) error {
	return func(writer io.Writer) (err error) {
		_, err = io.WriteString(writer, lexerH)
		if err != nil {
			return
		}
		return
	}
}

const (
	lexerH = `// generated by cppGen.go - do not edit
#ifndef CPPLEXERTEMPLATE_LEXER_H
#define CPPLEXERTEMPLATE_LEXER_H


#include <vector>
#include <memory>
#include <ostream>
#include "CharReader.h"
#include "Automata.h"

using TokenType = std::string;
using TokenValue = std::string;

class Token {
public:
    Token(TokenType type, TokenValue token);

    TokenType type;
    TokenValue token;

    friend std::ostream &operator<<(std::ostream &os, const Token &token);
};

class Lexer {
public:
    explicit Lexer(CharReader& charReader);

    Token nextToken();

    bool hasNext();

    void skipWhitespace();

private:
    CharReader &charReader;
    std::vector<std::unique_ptr<Automata>> automatas = std::vector<std::unique_ptr<Automata>>();
};


#endif //CPPLEXERTEMPLATE_LEXER_H`
)

// GenCMake
func genCMake() func(io.Writer) error {
	return func(writer io.Writer) (err error) {
		_, err = io.WriteString(writer, cmake)
		if err != nil {
			return
		}
		return
	}
}

const (
	cmake = `cmake_minimum_required(VERSION 3.5)
project(cppLexerTemplate)

set(CMAKE_CXX_STANDARD 11)

add_executable(cppLexerTemplate main.cpp CharReader.cpp CharReader.h UnicodeDef.h Lexer.cpp Lexer.h Automata.cpp Automata.h)
`
)

func wrapCppChar(c rune) interface{} {
	if c == '\'' {
		return "U'\\''"
	} else if unicode.IsPrint(c) {
		return fmt.Sprintf("U'%c'", c)
	} else {
		return fmt.Sprintf("0x%x", c)
	}
}